// Generated by CoffeeScript 1.6.3
/*
  rgba cycling by offset sin(time)
*/


(function() {
  var Configuration, FRAME, NOW, PI, Point, TICK_1, TICK_2, TICK_3, TICK_4, TICK_5, TICK_6, TICK_7, TICK_8, TIME, abs, animloop, between, blocker, clear, clearBlack, clearWhite, cos, decay, degToRad, drawPoints, flipBlocker, glitch, hsla, hyp, imageSmoothing, initGui, initPoints, interpolate, radToDeg, rainbowCircle, rgba, sin, tan, tick, x_interval, y_interval;

  TIME = 0;

  NOW = Date.now();

  FRAME = 0;

  TICK_1 = 0;

  TICK_2 = 0;

  TICK_3 = 0;

  TICK_4 = 0;

  TICK_5 = 0;

  TICK_6 = 0;

  TICK_7 = 0;

  TICK_8 = 0;

  tick = function() {
    TICK_1 += cfg.ticker_1;
    TICK_2 += cfg.ticker_2;
    TICK_3 += cfg.ticker_3;
    TICK_4 += cfg.ticker_4;
    TICK_5 += cfg.ticker_5;
    TICK_6 += cfg.ticker_6;
    TICK_7 += cfg.ticker_7;
    return TICK_8 += cfg.ticker_8;
  };

  PI = Math.PI;

  sin = function(a) {
    return Math.sin(a);
  };

  cos = function(a) {
    return Math.cos(a);
  };

  tan = function(a) {
    return Math.tan(a);
  };

  abs = function(a) {
    return Math.abs(a);
  };

  hyp = function(a, b) {
    return Math.sqrt(a * a + b * b);
  };

  radToDeg = function(rad) {
    return rad / (Math.PI / 180);
  };

  degToRad = function(deg) {
    return deg * (Math.PI / 180);
  };

  between = function(min, x, max) {
    return Math.min(Math.max(x, min), max);
  };

  interpolate = function(a, b, t) {
    return a * (1 - t) + b * t;
  };

  rgba = function(r, g, b, a) {
    if (r == null) {
      r = 255;
    }
    if (g == null) {
      g = 0;
    }
    if (b == null) {
      b = 255;
    }
    if (a == null) {
      a = 1;
    }
    r = between(0, r | 0, 255);
    g = between(0, g | 0, 255);
    b = between(0, b | 0, 255);
    a = between(0, a, 1);
    return "rgba( " + r + ", " + g + ", " + b + ", " + a + ")";
  };

  hsla = function(h, s, l, a) {
    if (h == null) {
      h = 0;
    }
    if (s == null) {
      s = 100;
    }
    if (l == null) {
      l = 50;
    }
    if (a == null) {
      a = 1;
    }
    h = (h | 0) % 360;
    s = between(0, s, 100);
    l = between(0, l, 100);
    a = between(0, a, 1);
    return "hsla(" + h + ", " + s + "%, " + l + "%, " + a + ")";
  };

  clear = function(context) {
    return context.clearRect(context.canvas.left, context.canvas.top, context.canvas.width, context.canvas.height);
  };

  clearWhite = function(context) {
    context.fillStyle = 'white';
    return context.fillRect(context.canvas.left, context.canvas.top, context.canvas.width, context.canvas.height);
  };

  clearBlack = function(context) {
    context.fillStyle = 'black';
    return context.fillRect(context.canvas.left, context.canvas.top, context.canvas.width, context.canvas.height);
  };

  window.rainbow = function(a, offset) {
    var b, g, r;
    if (offset == null) {
      offset = 1;
    }
    r = sin(a + 0 * PI / 3 * offset) * 117 + 128;
    g = sin(a + 2 * PI / 3 * offset) * 117 + 128;
    b = sin(a + 4 * PI / 3 * offset) * 117 + 128;
    return rgba(r, g, b, 1);
  };

  rainbowCircle = function() {
    var i, j, square_height, square_width, x, x_adj, y, y_adj, _i, _ref, _ref1, _results;
    square_height = hyp(canvas.height, canvas.width) / cfg.size;
    square_width = square_height;
    ctx.strokeStyle = 'black';
    _results = [];
    for (i = _i = _ref = canvas.left + square_width * 2, _ref1 = canvas.right - square_width * 2; square_width > 0 ? _i < _ref1 : _i > _ref1; i = _i += square_width) {
      _results.push((function() {
        var _j, _ref2, _ref3, _results1;
        _results1 = [];
        for (j = _j = _ref2 = canvas.top + square_height * 2, _ref3 = canvas.bottom - square_height * 2; square_height > 0 ? _j < _ref3 : _j > _ref3; j = _j += square_height) {
          x_adj = cos(i * cfg.x_a / canvas.width - cfg.m_sens * Mouse.x / canvas.width + TICK_2);
          y_adj = cos(j * cfg.y_a / canvas.height + cfg.m_sens * Mouse.y / canvas.height + TICK_3);
          ctx.fillStyle = rainbow(TICK_1 - x_adj - y_adj, cfg.sat * -sin(x_adj + y_adj));
          x = i;
          x += sin(j * cfg.x_wv_v - i * cfg.x_wv_h + TICK_4) * square_width / 2;
          x -= sin(j * cfg.x_wv_v2 - i * cfg.x_wv_h2 + TICK_5) * square_width / 2;
          y = j;
          y += sin(j * cfg.y_wv_v - i * cfg.y_wv_h + TICK_6) * square_width / 2;
          y -= sin(j * cfg.y_wv_v2 - i * cfg.y_wv_h2 + TICK_7) * square_width / 2;
          ctx.beginPath();
          ctx.arc(x, y, square_width / 2 - 1, 0, 2 * PI, true);
          ctx.closePath();
          ctx.fill();
          if (cfg.stroke) {
            _results1.push(ctx.stroke());
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  Point = (function() {
    function Point(x_orig, y_orig, x, y) {
      this.x_orig = x_orig;
      this.y_orig = y_orig;
      this.x = x != null ? x : this.x_orig;
      this.y = y != null ? y : this.y_orig;
    }

    Point.prototype.calc = function() {
      var i, j, square_height, square_width, x, x_adj, y, y_adj;
      square_height = hyp(canvas.height, canvas.width) / cfg.size;
      square_width = square_height;
      i = this.x_orig;
      j = this.y_orig;
      x_adj = cos(i * cfg.x_a / canvas.width + TICK_2);
      y_adj = cos(j * cfg.y_a / canvas.height + TICK_3);
      x = i;
      x += sin(j * cfg.x_wv_v - i * cfg.x_wv_h + TICK_4) * square_width / 2;
      x -= sin(j * cfg.x_wv_v2 - i * cfg.x_wv_h2 + TICK_5) * square_width / 2;
      y = j;
      y += sin(j * cfg.y_wv_v - i * cfg.y_wv_h + TICK_6) * square_width / 2;
      y -= sin(j * cfg.y_wv_v2 - i * cfg.y_wv_h2 + TICK_7) * square_width / 2;
      this.x = x;
      return this.y = y;
    };

    return Point;

  })();

  x_interval = 150;

  y_interval = x_interval;

  initPoints = function() {
    var i, j, _i, _j, _k, _ref, _ref1, _ref2, _ref3, _ref4;
    window.points = [];
    for (i = _i = _ref = canvas.left, _ref1 = canvas.right; x_interval > 0 ? _i < _ref1 : _i > _ref1; i = _i += x_interval) {
      points.push([]);
    }
    for (i = _j = 0, _ref2 = points.length; _j < _ref2; i = _j += 1) {
      for (j = _k = _ref3 = canvas.top, _ref4 = canvas.bottom; y_interval > 0 ? _k < _ref4 : _k > _ref4; j = _k += y_interval) {
        points[i].push(new Point(i * x_interval - canvas.width / 2, j));
      }
    }
    console.dir(points[0][0]);
    return true;
  };

  window.addEventListener('resize', initPoints, false);

  window.addEventListener('orientationChange', initPoints, false);

  drawPoints = function() {
    var hue_in, hue_x, hue_x_delta, hue_y, hue_y_delta, i, j, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
    for (i = _i = 0, _ref = points.length; _i < _ref; i = _i += 1) {
      for (j = _j = 0, _ref1 = points[i].length; _j < _ref1; j = _j += 1) {
        points[i][j].calc();
      }
    }
    for (i = _k = 1, _ref2 = points.length; _k < _ref2; i = _k += 1) {
      for (j = _l = 1, _ref3 = points[i].length; _l < _ref3; j = _l += 1) {
        hue_x = points[i][j].x / canvas.width * 2;
        hue_y = points[i][j].y / canvas.height * 2;
        hue_x_delta = (hue_x - points[i][j].x_orig) / canvas.width * 2;
        hue_y_delta = (hue_y - points[i][j].y_orig) / canvas.height * 2;
        hue_in = cos(hue_x * 3) + cos(hue_y * 3);
        ctx.strokeStyle = rainbow(hue_in + TICK_1 / 10, 1);
        ctx.beginPath();
        ctx.moveTo(points[i - 1][j - 1].x, points[i - 1][j - 1].y);
        ctx.lineTo(points[i][j - 1].x, points[i][j - 1].y);
        ctx.lineTo(points[i][j].x, points[i][j].y);
        ctx.lineTo(points[i - 1][j].x, points[i - 1][j].y);
        ctx.lineTo(points[i - 1][j - 1].x, points[i - 1][j - 1].y);
        ctx.closePath();
        if (cfg.fill) {
          ctx.fill();
        }
        if (cfg.stroke) {
          ctx.stroke();
        }
      }
    }
    return true;
  };

  decay = function(h, v, s, r) {
    var dh, dw, dx, dy;
    ctx.save();
    ctx.translate(h, v);
    if (r !== 0) {
      ctx.rotate(r);
    }
    dx = -(canvas.width + s) / 2;
    dy = -(canvas.height + s) / 2;
    dw = canvas.width + s;
    dh = canvas.height + s;
    ctx.drawImage(canvas, dx, dy, dw, dh);
    return ctx.restore();
  };

  glitch = function(context) {
    var d, i, modulo, mult2, multiplier, n;
    d = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
    n = 0;
    multiplier = 1.001;
    mult2 = 2;
    modulo = 255 / mult2;
    while (n < d.width * d.height) {
      i = n * 4;
      if (n % (11 + Date.now() % 22) < 4) {
        d.data[i + 0] = (d.data[i + 0] * multiplier % modulo) * mult2;
        d.data[i + 1] = (d.data[i + 1] * multiplier % modulo) * mult2;
        d.data[i + 2] = (d.data[i + 2] * multiplier % modulo) * mult2;
      }
      if (d.data[i + 1] > 200 && n % 3 === 0) {
        d.data[i + 3] = 0;
      }
      n++;
    }
    return context.putImageData(d, 0, 0);
  };

  blocker = document.getElementById('blocker');

  blocker.style.visibility = 'hidden';

  flipBlocker = function() {
    switch (blocker.style.visibility) {
      case 'visible':
        return blocker.style.visibility = 'hidden';
      case 'hidden':
        return blocker.style.visibility = 'visible';
    }
  };

  window.onmousedown = flipBlocker;

  imageSmoothing = function(context, a) {
    if (context == null) {
      context = ctx;
    }
    if (a == null) {
      a = false;
    }
    context.webkitImageSmoothingEnabled = a;
    context.mozImageSmoothingEnabled = a;
    return context.imageSmoothingEnabled = a;
  };

  animloop = function() {
    var alternator, horizontal, mxc, myc, rotate, spread, vertical;
    requestAnimationFrame(animloop);
    FRAME++;
    tick();
    imageSmoothing(ctx, false);
    if (FRAME % 277 < (Date.now() % 7)) {
      glitch(ctx);
    }
    mxc = Mouse.x / canvas.width - 0.5;
    myc = Mouse.y / canvas.height - 0.5;
    horizontal = mxc * 4;
    vertical = myc * 4;
    alternator = Math.sin(Date.now() / 12800) + 1.1;
    spread = alternator * 4;
    rotate = 0;
    decay(1, 1, -spread, 0.008 * alternator - (Math.PI + Mouse.clicks / 2 + 1));
    decay(-1, -1, spread, -0.007 * alternator + (Math.PI + Mouse.clicks / 2 + 1));
    if (FRAME % 377 < (Date.now() % 9)) {
      return glitch(ctx);
    }
  };

  Configuration = function() {
    return {
      size: 36,
      stroke: true,
      fill: false,
      x_wv_h: 0.001,
      x_wv_v: 0.002,
      y_wv_h: 0.003,
      y_wv_v: 0.004,
      x_wv_h2: -0.005,
      x_wv_v2: -0.006,
      y_wv_h2: -0.007,
      y_wv_v2: -0.008,
      m_sens: 0.1,
      offset_3: 1,
      offset_2: 1,
      offset_1: 1,
      x_a: 1,
      y_a: -3,
      sat: 0.5,
      ticker_1: 1 / 16,
      ticker_2: 1 / 17,
      ticker_3: 1 / 32,
      ticker_4: 1 / 146,
      ticker_5: 1 / 156,
      ticker_6: 1 / 166,
      ticker_7: 1 / 176,
      ticker_8: 1 / 186
    };
  };

  window.cfg = new Configuration();

  initGui = function() {
    var f_hue, f_time, f_waves, gui;
    gui = new dat.GUI();
    gui.remember(cfg);
    gui.close();
    dat.GUI.toggleHide();
    gui.add(cfg, 'size', 1, 128);
    gui.add(cfg, 'stroke');
    gui.add(cfg, 'fill');
    f_waves = gui.addFolder('Waves');
    f_waves.add(cfg, 'x_wv_v', -1 / 40, 1 / 40);
    f_waves.add(cfg, 'x_wv_v2', -1 / 40, 1 / 40);
    f_waves.add(cfg, 'y_wv_h', -1 / 40, 1 / 40);
    f_waves.add(cfg, 'y_wv_h2', -1 / 40, 1 / 40);
    f_waves.add(cfg, 'y_wv_v', -1 / 40, 1 / 40);
    f_waves.add(cfg, 'y_wv_v2', -1 / 40, 1 / 40);
    f_waves.add(cfg, 'x_wv_h', -1 / 40, 1 / 40);
    f_waves.add(cfg, 'x_wv_h2', -1 / 40, 1 / 40);
    f_waves.add(cfg, 'x_a', -30, 30);
    f_waves.add(cfg, 'y_a', -30, 30);
    f_time = gui.addFolder('Time');
    f_time.add(cfg, 'ticker_1', -1 / 50, 1 / 50);
    f_time.add(cfg, 'ticker_2', -1 / 50, 1 / 50);
    f_time.add(cfg, 'ticker_3', -1 / 50, 1 / 50);
    f_time.add(cfg, 'ticker_4', -1 / 50, 1 / 50);
    f_time.add(cfg, 'ticker_5', -1 / 50, 1 / 50);
    f_time.add(cfg, 'ticker_6', -1 / 50, 1 / 50);
    f_time.add(cfg, 'ticker_7', -1 / 50, 1 / 50);
    f_hue = gui.addFolder('Hue');
    f_hue.add(cfg, 'sat', 0, 1);
    f_hue.add(cfg, 'offset_1', 0, PI);
    f_hue.add(cfg, 'offset_2', 0, PI);
    return f_hue.add(cfg, 'offset_3', 0, PI);
  };

  window.onload = function() {
    initGui();
    initPoints();
    return animloop();
  };

}).call(this);

/*
//@ sourceMappingURL=01.map
*/
